@model X.PagedList.IPagedList<IssueManager.Models.Issue>
@using X.PagedList.Mvc.Core;
<link href="~/Content/PagedList.css" rel="stylesheet" type="text/css" />

@{
    ViewData["Title"] = "Issue list";
}

<h1>Index</h1>

<form asp-controller="Issues" asp-action="Index" method="get">
    <p>
        <input type="hidden" name="projectId" value="@ViewData["projectId"]" />
        <input type="text" name="search" value="@ViewData["search"]" placeholder="Search by description" />
        <input type="submit" value="Search" />
    </p>
</form>

<p>
    <a asp-action="Create" asp-route-projectId="@ViewData["projectId"]">Submit new issue</a>
</p>

@{
    // check if all issues belong to same project and write project name if this is the case. Could also somehow check query string, but this would duplicate parameter name here and in controller, or add extra data to view, but it would require creating a new class/model
    var pid = Model.Count() > 0 ? Model.First().project?.Id : null;
    if (pid != null && Model.All(issue => issue.project.Id == pid))
	{
        <p>Issues for project: @Model.First().project.Name</p>
    }
    else
    {
        pid = null; // update it to null if second check above failed
        <p>All issues:</p>
    }
}

@if (Model.Count() == 0)
{
	<p>No issues have been submitted yet.</p>
}
else
{
	<p>Issues submitted so far:</p>
}
<table class="table">
    <thead>
        <tr>
            <th>
                @{
                    // workaround to allow conditionally passing projectId to the link, it's important it's missing entirely, because otherwise it would show issues of project with id = 0
                    // I don't want to deal with route parameters etc.
                    var baseDict = new Dictionary<string, object> { ["search"] = ViewData["search"] };
                    if (ViewData.ContainsKey("projectId") && ViewData["projectId"] != null)
					{
						baseDict["projectId"] = Convert.ToInt32(ViewData["projectId"]);
					}
                    // else not present
                }
                @Html.ActionLink("Project", "Index", "Projects", baseDict, null)
            </th>
            <th>
                @Html.ActionLink("Title", "Index", "Issues", baseDict.Append(new("sort", ViewBag.titleSort)), null)
            </th>
            <th>
                @Html.DisplayNameFor(model => model[0].Description)
            </th>
            <th>
                @{//@Html.DisplayNameFor(model => model.Author)
                }
                @Html.ActionLink("Author", "Index", "Issues", baseDict.Append(new("sort", ViewBag.authorSort)), null)
            </th>
            <th>
                @Html.DisplayNameFor(model => model[0].SubmitDate)
            </th>
            <th>
                @Html.DisplayNameFor(model => model[0].CloseDate)
            </th>
            <th>
                @Html.DisplayNameFor(model => model[0].LastUpdateDate)
            </th>
            <th>
                @Html.ActionLink("Status", "Index", "Issues", baseDict.Append(new("sort", ViewBag.statusSort)), null)
            </th>
            <th></th>
        </tr>
    </thead>
    <tbody>
@foreach (var item in Model) {
        <tr>
            <td>
				<a asp-controller="Projects" asp-action="Details" asp-route-id="@item.project.Id">@Html.DisplayFor(modelItem => item.project.Name)</a>
            <td>
                @Html.DisplayFor(modelItem => item.Title)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.Description)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.Author)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.SubmitDate)
            </td>
            <td>
                @if (item.Status == IssueStatus.CLOSED)
                {
                    @Html.DisplayFor(modelItem => item.CloseDate)
                }
                else
                {
                    <text>N/A</text>
                }
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.LastUpdateDate)
            </td>
            <td>
                <!-- this workaround is needed, because you can't call a method in a lambda expression -->
                @{var str = Issue.getIssueStatusEnumText((IssueStatus)item.Status);}
                @Html.DisplayFor(modelItem => str)
            </td>
            <td>
                <!--
                    <a asp-controller="Issues" asp-action="Index" asp-all-route-data="issuesParam">View project issues (issuesCount)</a> |
                -->
                    @{
                        var commentsParam = new Dictionary<string, string>
                        {
                            { "issueId", item.Id.ToString() }
                        };
                        var commentsCount = (item.Comments ?? new()).Count();
                        // note: to make it not-null we need to use eager loading on Issue list
                    }
                <a asp-controller="Comments" asp-route-id="@item.Id" asp-all-route-data="commentsParam">View comments (@commentsCount)</a> |
                <a asp-action="Edit" asp-route-id="@item.Id">Edit</a> |
                <a asp-action="Details" asp-route-id="@item.Id">Details</a> |
                <a asp-action="Delete" asp-route-id="@item.Id">Delete</a>
            </td>
        </tr>
}
    </tbody>
</table>

<!-- setup paging -->
<br />
Page @(Model.PageCount < Model.PageNumber ? 0 : Model.PageNumber) of @Model.PageCount

@Html.PagedListPager((X.PagedList.IPagedList)Model, page => Url.Action("Index",
    new { page, sort = ViewBag.currentSort, currentFilter = ViewBag.currentFilter, projectId = ViewData["projectId"], search = ViewData["search"] }))

<!--<style>ul.pagination > li:after {content: " | ";}</style>-->